module coef
  !Part of SDE routines for K2, written by Shah Saad Alam, Rice University
  !email @ Shah.Saad.Alam@rice.edu
  !--------------------
  ! This routine contains any functions needed to obtain local sigma and b
  ! coefficients needed for a particular kick. It also contains readCoordinates() to
  ! read in the alpha_0 and E coordinate values of the domain grid for the
  ! diffusion coefficients. The sigma and b coefficients are read in on the coordinate grid
  ! from a file in readmasterfile().
  !---------------------
  ! The actual diffusion coeffcients are available on the QARBM focus group google drive,
  ! and were generated by Dr. Qianli Ma.
  ! Links can be found under the focus group's page in the GEM wiki.
  !----------------------
  ! For more detailed background, see the file:
  ! "Summary of SDE for K2" available online by request.module coef
  use conversion

  implicit none 

  ! Number of coordinate points, e.g. we have E_length values of energy.
  integer , parameter:: E_length=71;
  integer , parameter:: a_length=46;
  integer , parameter :: L_length=9;
  integer , parameter :: t_length =48;
  integer , parameter :: MLT_length=4;

  ! Matrices to hold coefficients after reading them from file in readMasterFile()
  real, dimension(t_length, L_length, MLT_length, a_length, E_length) :: s11, s21, s22, b1, b2;

  ! Arrays of the values of the coordinate points. Time and MLT are hard-coded for now.
  real, dimension(a_length) :: alpha_list;
  real, dimension(E_length) :: E_list;
  real, dimension(L_length) :: L_list= (/3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0/);

  logical OK;

contains


  subroutine readCoordinates()
    ! Reads in the alpha_0, Energy coordinate values from their respective files.
    ! The files are available within the respective Dr. Ma's diffusion coefficients folders.
    ! For now, the time, MLT and L coordinates are hard-coded in.

    open(10, FiLE='PitchAngle_46.txt', FORM='FORMATTED',STATUS='OLD', ACTION='READ')
    inquire(FILE='PitchAngle_46.txt', Exist=OK);
    if( .not. OK) then
       write(*,*) "Pitch angle file not found";
    end if
    
    read(10, fmt=*) alpha_list;
    close(10);

    open(20, FiLE='Energy_71.txt', FORM='FORMATTED',STATUS='OLD', ACTION='READ')
    inquire(FILE='Energy_71.txt', Exist=OK);
    if( .not. OK) then
       write(*,*) "Energy file not found";
    end if
    read(20, fmt=*) E_list;
    close(20);

  end subroutine readCoordinates

  subroutine readMasterFile()

    integer :: tcount=1
    integer :: Lcount=1
    integer :: MLTcount=1
    integer :: acount=1
    integer :: Ecount=1
    integer :: t, MLT
    real :: L, E, alpha


    open(1, FiLE='masterfile.txt', FORM='FORMATTED',STATUS='OLD', ACTION='READ')
    inquire(FILE='masterfile.txt', Exist=OK);
    if( .not. OK) then
       write(*,*) "Masterfile not found";
    end if

    ! Read in all the coefficients
    do tcount = 1,t_length
       do Lcount = 1,L_length
          do MLTcount = 1,MLT_length
             do acount = 1,a_length
                do Ecount = 1,E_Length

                   read(unit=1, fmt=*) t, L , MLT, alpha, E , &
                        s11(tcount, Lcount, MLTcount, acount, Ecount), &
                        s21(tcount, Lcount, MLTcount, acount, Ecount), &
                        s22(tcount, Lcount, MLTcount, acount, Ecount), &
                        b1(tcount, Lcount, MLTcount, acount, Ecount), &
                        b2(tcount, Lcount, MLTcount, acount, Ecount)



                end do ! tcount
             end do ! Lcount
          end do ! MLTcount
       end do ! acount
    end do ! Ecount

    close(UNIT=1)


  end subroutine readMasterFile

  subroutine getsigmab( aii, pi, L, phi, t , sigma, bv)

    ! Takes in initial alpha_0 from 0 deg to 180 deg.
    ! Takes initial pi, L, time
    
    real, intent(in) :: aii, pi, L, phi, t
    real :: ai;

    ! Returns the sigma and b coefficients at these values
    real, dimension(3), intent(out) :: sigma
    real, dimension(2), intent(out) :: bv
    real :: Energy

    integer :: tindex, Lindex_l, Lindex_h, Mindex, aindex_l, Eindex_l, aindex_h, Eindex_h;

    ! If we are out of bounds or doing something illegal, it's DEFCON 4 or 5.
    ! and no, I haven't watched the show. I don't even know *what* show this reference
    ! is from.

    ! DEFCON 5 means something is horribly wrong with the if statments, i.e. logically this
    ! error should never have occured.
    ! DEFCON 3 means that we are out of bounds, but that is just because we might have
    ! called getsigmab at a coordinate point outside the domain of the diffusion grid.
    integer :: defcon=0;

    ! Now, aii can be 0 - 180 deg. However, the diffuson coefficients are limited to 1-89.5
    ! So,
    if (aii<=90) then
       ai= aii;
    else
       ai=180-aii;
    end if
    

    Energy = E_from_p(pi);! E in MeV



    ! Over here we are sorting by MLT.
    ! For MLT 12-20h, we have zero diffusion coefficients, hence sigma and b coefficients are
    ! also zero.
    if ( phi >0 .and. phi<PI_8*2/3) then 
       defcon=2;
       
       ! MLT sector 20-24h
    else if (phi >=PI_8*2.0/3.0 .and. phi <= PI_8) then
       Mindex=4;

       ! MLT sector 0-4h
    else if (phi >PI_8 .and. phi <= PI_8*4.0/3.0) then
       Mindex = 1;

       ! MLT sector 4-8h
    else if (phi >PI_8*4.0/3.0 .and. phi<= PI_8*5.0/3.0) then
       Mindex = 2;

       ! MLT sector 8-12h
    else if (phi >PI_8*5.0/3.0 .and. (phi==0.0 .or. phi <= 2.0*PI_8)) then 
       Mindex = 3;

    end if

    ! Convert time, provided in days starting 17th March 00:00
    ! to totalnumber of hours. Essentially, the diffusion coefficients
    ! are in 1hr bins, and so are our sigma,b values.
    tindex = floor(t*24)+1;

    ! Checking for whether the time and MLT are within bounds.
    ! Ideally, they should be.

    if( (Mindex<1.or. Mindex>MLT_length) .and. defcon /= 2) then 
       write(*,*) "MLT index out of bounds, THIS SHOULD NOT HAPPEN";
       write(*,*) Mindex,phi;
       defcon=5;
    end if

    if( tindex<1 .or. tindex>t_length ) then
       write(*,*) "Time index out of bounds";
       defcon=3;
    end if


    if (ai < alpha_list(1) .or. ai > alpha_list(a_length)) then

       write (*,*) "ai outside bounds of alpha_list";
       defcon=3;
    end if

    if (L< L_list(1) .or. L > L_list(L_length)) then

       write (*,*) "L outside bounds of L_list";
       defcon=3;
    end if

    if (Energy< E_list(1) .or. Energy > E_list(E_length)) then

       write (*,*) "Energy outside bounds of E_list";
       defcon=3;
       
    end if
    
    call findIndices(ai, Energy, L,  aindex_l, aindex_h,Eindex_l, Eindex_h, Lindex_l, Lindex_h)

    if (aindex_l <1 .or. aindex_l >a_length) then
       write(*,*) "Alpha low out of bounds, THIS SHOULD  NOT HAPPEN"
       defcon=5;
    end if

    if (aindex_h <1 .or. aindex_h >a_length) then
       write(*,*) "Alpha high out of bounds, THIS SHOULD NOT HAPPEN"
       defcon=5;
    end if


    if (Eindex_l <1 .or. Eindex_l >E_length) then
       write(*,*) "Energy  low out of bounds"
       defcon=5;
    end if

    if (Eindex_h <1 .or. Eindex_h >E_length) then
       write(*,*) "Energy high out of bounds"
       defcon=5;
    end if

    if(defcon ==0 ) then

     
       sigma(1)=interpolate(ai, Energy, L, aindex_l, aindex_h, Eindex_l, Eindex_h, Lindex_l, Lindex_h,&
            tindex, Mindex,  s11 );

       sigma(2)=interpolate(ai, Energy, L, aindex_l, aindex_h, Eindex_l, Eindex_h, Lindex_l, Lindex_h, &
            tindex, Mindex, s21);

       sigma(3)=interpolate(ai, Energy, L, aindex_l, aindex_h, Eindex_l, Eindex_h, Lindex_l, Lindex_h, &
       tindex, Mindex,    s22 );

       bv(1)=interpolate(ai, Energy, L, aindex_l, aindex_h, Eindex_l, Eindex_h, Lindex_l, Lindex_h, &
            tindex, Mindex, b1 );

       bv(2)=interpolate(ai, Energy, L, aindex_l, aindex_h, Eindex_l, Eindex_h, Lindex_l, Lindex_h, &
            tindex, Mindex, b1 );
    else
       sigma(1)=0;
       sigma(2)=0;
       sigma(3)=0;

       bv(1)=0;
       bv(2)=0;
    end if

  end subroutine getsigmab




  subroutine findIndices(ai, Energy, L,  aindex_l,  aindex_h, Eindex_l,Eindex_h, Lindex_l, Lindex_h)

    real, intent(in) :: ai, Energy, L;
    integer, intent(out) :: Lindex_l, Lindex_h, aindex_l, Eindex_l, aindex_h, Eindex_h;

    integer :: cout;

    do cout =1,a_length

       if (alpha_list(cout) <= ai .and. alpha_list(cout+1)>= ai) then
          aindex_l=cout;
          aindex_h = cout+1;
       end if
    end do

    do cout =1,E_length

       if (E_list(cout) <= Energy .and. E_list(cout+1)>= Energy) then
          Eindex_l=cout;
          Eindex_h = cout+1;
       end if
    end do

    do cout =1,L_length

       if (L_list(cout) <= L .and. L_list(cout+1)>= L) then
          Lindex_l=cout;
          Lindex_h = cout+1;
       end if
    end do


  end subroutine findIndices

  real function interpolate(ai, Energy, L, aindex_l, aindex_h, Eindex_l, Eindex_h, Lindex_l, Lindex_h,tindex, Mindex,  matrix)

    integer, intent(in) :: aindex_l, aindex_h, Eindex_l, Eindex_h, Lindex_l, Lindex_h, tindex, Mindex
    real, intent(in) :: ai, Energy, L;
    real, intent(in), dimension(:,:,:,:,:) :: matrix
   
    real :: xd,yd,zd;

    real :: c00,c01,c10,c11,c0,c1,c;
 

    zd = (L - L_list(Lindex_l) );
    xd= (ai - alpha_list(aindex_l) );
    yd = (Energy - E_list(Eindex_l) );

    c00 = matrix(tindex, Lindex_l, Mindex, aindex_l, Eindex_l)*(1-xd) + matrix(tindex,Lindex_l, Mindex,aindex_h, Eindex_l)*xd;


    c01 = matrix(tindex,Lindex_h,Mindex, aindex_l, Eindex_l)*(1-xd) + matrix(tindex,Lindex_h,Mindex, aindex_h, Eindex_l)*xd;

    c10 = matrix(tindex,Lindex_l, Mindex,aindex_l, Eindex_h)*(1-xd) + matrix(tindex,Lindex_l, Mindex,aindex_h, Eindex_h)*xd;

    c11 = matrix(tindex,Lindex_h, Mindex,aindex_l, Eindex_h)*(1-xd) + matrix(tindex,Lindex_h,Mindex, aindex_h, Eindex_h)*xd;

    c0= c00*(1-yd)+c10*yd;
    c1=c01*(1-yd)+c11*yd;
    c=c0*(1-zd)+c1*zd;

    interpolate=c;

  end function interpolate



end module coef
